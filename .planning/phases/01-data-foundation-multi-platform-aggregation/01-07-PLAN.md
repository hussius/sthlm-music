---
phase: 01-data-foundation-multi-platform-aggregation
plan: 07
type: execute
wave: 4
depends_on:
  - 01-03
  - 01-04
  - 01-05
  - 01-06
files_modified:
  - src/deduplication/exact-match.ts
  - src/deduplication/fuzzy-match.ts
  - src/deduplication/manual-review-queue.ts
  - src/deduplication/deduplicator.ts
autonomous: true
requirements:
  - DATA-05
  - QUAL-01

must_haves:
  truths:
    - System detects duplicate events across different platforms
    - Exact matches (venue+date) are merged automatically
    - Fuzzy matches (similar artist/name) are detected with >90% similarity
    - Edge cases (70-90% similarity) are queued for manual review
    - Deduplication accuracy is >95% (minimal false positives/negatives)
  artifacts:
    - path: "src/deduplication/exact-match.ts"
      provides: "Database constraint-based exact matching"
      exports: ["checkExactMatch"]
      min_lines: 30
    - path: "src/deduplication/fuzzy-match.ts"
      provides: "String similarity-based fuzzy matching"
      exports: ["findFuzzyCandidates", "calculateSimilarity"]
      min_lines: 80
    - path: "src/deduplication/manual-review-queue.ts"
      provides: "Edge case storage for manual review"
      exports: ["addToReviewQueue", "getReviewQueue"]
      min_lines: 40
    - path: "src/deduplication/deduplicator.ts"
      provides: "Multi-stage deduplication pipeline"
      exports: ["deduplicateEvent", "DeduplicationResult"]
      min_lines: 60
  key_links:
    - from: "src/deduplication/deduplicator.ts"
      to: "src/deduplication/exact-match.ts"
      via: "stage 1 exact matching"
      pattern: "checkExactMatch"
    - from: "src/deduplication/deduplicator.ts"
      to: "src/deduplication/fuzzy-match.ts"
      via: "stage 2 fuzzy matching"
      pattern: "findFuzzyCandidates"
    - from: "src/deduplication/fuzzy-match.ts"
      to: "fuzzball"
      via: "string similarity calculation"
      pattern: "fuzzball\\.token_set_ratio"
---

<objective>
Implement multi-stage deduplication engine to detect and merge duplicate events across Ticketmaster, AXS, DICE, and venue websites. Uses exact matching (venue+date), fuzzy matching (artist/event name similarity), and manual review queue for edge cases, targeting >95% accuracy.

Purpose: The same concert may appear on Ticketmaster, DICE, and the venue's own website with slight naming variations. Without deduplication, users see the same event 3 times. This system merges duplicates while preserving ticket links to all platforms.

Output: Multi-stage deduplication pipeline with exact matching, fuzzy matching using fuzzball.js, manual review queue for ambiguous cases, and integration with existing crawlers.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-data-foundation-multi-platform-aggregation/01-RESEARCH.md
@.planning/phases/01-data-foundation-multi-platform-aggregation/01-03-SUMMARY.md
@.planning/phases/01-data-foundation-multi-platform-aggregation/01-04-SUMMARY.md
@.planning/phases/01-data-foundation-multi-platform-aggregation/01-05-SUMMARY.md
@.planning/phases/01-data-foundation-multi-platform-aggregation/01-06-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement exact match and fuzzy match deduplication stages</name>
  <files>
    src/deduplication/exact-match.ts
    src/deduplication/fuzzy-match.ts
  </files>
  <action>
Implement the first two stages of the deduplication pipeline following RESEARCH.md Pattern 2 (Multi-Stage Deduplication Pipeline):

**Part A: Exact matching (exact-match.ts)**

1. Implement exact match using database unique constraint:
   ```typescript
   import { db } from '../db/client.js';
   import { events } from '../db/schema.js';
   import { and, eq } from 'drizzle-orm';
   import type { Event } from '../normalization/schemas.js';

   export async function checkExactMatch(event: Event): Promise<Event | null> {
     // Query for exact venue+date match (uses unique index)
     const matches = await db.select()
       .from(events)
       .where(and(
         eq(events.venue, event.venue),
         eq(events.date, event.date)
       ))
       .limit(1);

     return matches[0] || null;
   }

   export async function mergeEventData(existing: Event, incoming: Event): Promise<Event> {
     // Merge logic: keep existing core data, append new ticket link
     return {
       ...existing,
       // If incoming has better data, use it
       genre: incoming.genre !== 'other' ? incoming.genre : existing.genre,
       price: incoming.price || existing.price,
       // Combine ticket URLs (will be stored as separate entries with same venue+date)
       updatedAt: new Date()
     };
   }
   ```

**Part B: Fuzzy matching (fuzzy-match.ts)**

2. Implement fuzzy string matching using fuzzball.js:
   ```typescript
   import Fuzzball from 'fuzzball';
   import { db } from '../db/client.js';
   import { events } from '../db/schema.js';
   import { between } from 'drizzle-orm';
   import type { Event } from '../normalization/schemas.js';

   export interface FuzzyCandidate {
     event: Event;
     artistSimilarity: number;
     nameSimilarity: number;
     overallSimilarity: number;
   }

   export async function findFuzzyCandidates(event: Event): Promise<FuzzyCandidate[]> {
     // Find events within 24 hours of target event (allows for timezone/date parsing differences)
     const dayBefore = new Date(event.date);
     dayBefore.setHours(dayBefore.getHours() - 24);

     const dayAfter = new Date(event.date);
     dayAfter.setHours(dayAfter.getHours() + 24);

     const candidates = await db.select()
       .from(events)
       .where(between(events.date, dayBefore, dayAfter));

     // Calculate similarity for each candidate
     const scoredCandidates: FuzzyCandidate[] = [];

     for (const candidate of candidates) {
       // Skip if same source (can't be duplicate from same platform)
       if (candidate.sourcePlatform === event.sourcePlatform &&
           candidate.sourceId === event.sourceId) {
         continue;
       }

       // Calculate string similarities using token_set_ratio (handles word order differences)
       const artistSimilarity = Fuzzball.token_set_ratio(
         event.artist.toLowerCase(),
         candidate.artist.toLowerCase()
       );

       const nameSimilarity = Fuzzball.token_set_ratio(
         event.name.toLowerCase(),
         candidate.name.toLowerCase()
       );

       // Overall similarity: weighted average (artist more important than event name)
       const overallSimilarity = (artistSimilarity * 0.6) + (nameSimilarity * 0.4);

       // Only include if similarity is above threshold (50%)
       if (overallSimilarity > 50) {
         scoredCandidates.push({
           event: candidate,
           artistSimilarity,
           nameSimilarity,
           overallSimilarity
         });
       }
     }

     // Sort by similarity (highest first)
     return scoredCandidates.sort((a, b) => b.overallSimilarity - a.overallSimilarity);
   }

   export function calculateSimilarity(str1: string, str2: string): number {
     return Fuzzball.token_set_ratio(str1.toLowerCase(), str2.toLowerCase());
   }

   export function isDuplicateMatch(candidate: FuzzyCandidate): 'duplicate' | 'maybe' | 'not_duplicate' {
     // High confidence duplicate: both artist and name very similar
     if (candidate.artistSimilarity > 90 && candidate.nameSimilarity > 85) {
       return 'duplicate';
     }

     // Potential duplicate: needs manual review
     if (candidate.artistSimilarity > 75 && candidate.nameSimilarity > 70) {
       return 'maybe';
     }

     // Not a duplicate
     return 'not_duplicate';
   }
   ```

Note: Thresholds (90/85 for duplicate, 75/70 for maybe) are starting points from RESEARCH.md Open Question 3. These may need tuning based on production false positive/negative rates. Use token_set_ratio (not simple ratio) to handle word order differences like "Coldplay Live in Stockholm" vs "Stockholm: Coldplay Concert".
  </action>
  <verify>
Test exact matching:
  cat > test-exact-match.ts << 'EOF'
import { checkExactMatch } from './src/deduplication/exact-match.js';
import { db } from './src/db/client.js';
import { events } from './src/db/schema.js';

// Insert test event
const testEvent = {
  name: 'Test Concert',
  artist: 'Test Band',
  venue: 'Fasching',
  date: new Date('2026-06-15T20:00:00Z'),
  genre: 'rock',
  ticketUrl: 'https://example.com/1',
  sourceId: 'test-1',
  sourcePlatform: 'ticketmaster'
};

await db.insert(events).values(testEvent);

// Test exact match
const match = await checkExactMatch({
  ...testEvent,
  sourceId: 'test-2',
  sourcePlatform: 'dice',
  ticketUrl: 'https://example.com/2'
});

console.log('Exact match found:', match ? 'PASS' : 'FAIL');
console.log('Match details:', match?.name, match?.venue);
EOF

  tsx test-exact-match.ts
  Expected: Finds exact match for same venue+date

Test fuzzy matching:
  cat > test-fuzzy-match.ts << 'EOF'
import { findFuzzyCandidates, isDuplicateMatch } from './src/deduplication/fuzzy-match.js';

const testEvent = {
  name: 'Coldplay Live in Stockholm',
  artist: 'Coldplay',
  venue: 'Avicii Arena',
  date: new Date('2026-07-20T19:00:00Z'),
  genre: 'pop',
  ticketUrl: 'https://example.com',
  sourceId: 'test-3',
  sourcePlatform: 'axs'
};

// Assume similar event exists from different platform
const candidates = await findFuzzyCandidates(testEvent);

console.log(`Found ${candidates.length} candidates`);
candidates.forEach(c => {
  console.log(`  ${c.event.name} - ${c.overallSimilarity.toFixed(1)}% similar`);
  console.log(`    Classification: ${isDuplicateMatch(c)}`);
});
EOF

  tsx test-fuzzy-match.ts
  Expected: Finds similar events with similarity scores
  </verify>
  <done>
- checkExactMatch queries for venue+date duplicates
- findFuzzyCandidates searches events within 24-hour window
- Fuzzy matching uses token_set_ratio for word-order-insensitive comparison
- Similarity calculated for both artist and event name
- isDuplicateMatch classifies candidates (duplicate/maybe/not_duplicate)
- Thresholds: >90/85 = duplicate, >75/70 = maybe, else not duplicate
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement manual review queue and complete deduplication pipeline</name>
  <files>
    src/deduplication/manual-review-queue.ts
    src/deduplication/deduplicator.ts
    src/db/schema.ts
  </files>
  <action>
Complete the deduplication system with manual review queue and orchestration:

**Part A: Manual review queue (manual-review-queue.ts)**

1. Add review queue table to schema.ts:
   ```typescript
   export const reviewQueue = pgTable('review_queue', {
     id: uuid('id').defaultRandom().primaryKey(),
     eventId1: uuid('event_id_1').notNull().references(() => events.id),
     eventId2: uuid('event_id_2').notNull().references(() => events.id),
     artistSimilarity: integer('artist_similarity').notNull(),
     nameSimilarity: integer('name_similarity').notNull(),
     status: text('status').notNull().default('pending'),  // pending, merged, not_duplicate
     createdAt: timestamp('created_at').defaultNow().notNull(),
     reviewedAt: timestamp('reviewed_at'),
     reviewedBy: text('reviewed_by')
   });
   ```

2. Implement review queue operations:
   ```typescript
   import { db } from '../db/client.js';
   import { reviewQueue } from '../db/schema.js';
   import { eq } from 'drizzle-orm';
   import type { FuzzyCandidate } from './fuzzy-match.js';

   export async function addToReviewQueue(
     incomingEventId: string,
     candidate: FuzzyCandidate
   ): Promise<void> {
     await db.insert(reviewQueue).values({
       eventId1: incomingEventId,
       eventId2: candidate.event.id,
       artistSimilarity: Math.round(candidate.artistSimilarity),
       nameSimilarity: Math.round(candidate.nameSimilarity),
       status: 'pending'
     });
   }

   export async function getReviewQueue(limit: number = 100) {
     return db.select()
       .from(reviewQueue)
       .where(eq(reviewQueue.status, 'pending'))
       .limit(limit);
   }

   export async function markAsReviewed(
     queueId: string,
     decision: 'merged' | 'not_duplicate',
     reviewedBy: string = 'system'
   ): Promise<void> {
     await db.update(reviewQueue)
       .set({
         status: decision,
         reviewedAt: new Date(),
         reviewedBy
       })
       .where(eq(reviewQueue.id, queueId));
   }
   ```

**Part B: Deduplication orchestrator (deduplicator.ts)**

3. Implement complete pipeline:
   ```typescript
   import { checkExactMatch, mergeEventData } from './exact-match.js';
   import { findFuzzyCandidates, isDuplicateMatch } from './fuzzy-match.js';
   import { addToReviewQueue } from './manual-review-queue.js';
   import type { Event } from '../normalization/schemas.js';

   export type DeduplicationResult =
     | { status: 'duplicate'; existingEventId: string }
     | { status: 'unique' }
     | { status: 'manual_review'; candidateIds: string[] };

   export async function deduplicateEvent(event: Event): Promise<DeduplicationResult> {
     // Stage 1: Exact match on venue + date
     const exactMatch = await checkExactMatch(event);

     if (exactMatch) {
       console.log(`Exact match found for ${event.name} at ${event.venue}`);
       return { status: 'duplicate', existingEventId: exactMatch.id };
     }

     // Stage 2: Fuzzy match on artist + date
     const candidates = await findFuzzyCandidates(event);

     if (candidates.length === 0) {
       // No candidates found, definitely unique
       return { status: 'unique' };
     }

     // Check each candidate
     for (const candidate of candidates) {
       const classification = isDuplicateMatch(candidate);

       if (classification === 'duplicate') {
         // High confidence duplicate
         console.log(`Fuzzy match found: ${event.name} ≈ ${candidate.event.name} (${candidate.overallSimilarity.toFixed(1)}%)`);
         return { status: 'duplicate', existingEventId: candidate.event.id };
       }

       if (classification === 'maybe') {
         // Add to manual review queue
         console.log(`Potential duplicate queued for review: ${event.name} ≈ ${candidate.event.name} (${candidate.overallSimilarity.toFixed(1)}%)`);
         // Note: Would need event ID, so need to modify flow to pass ID after insert
         // For now, just log
       }
     }

     // No high-confidence matches found
     return { status: 'unique' };
   }

   export async function deduplicateAndSave(event: Event): Promise<void> {
     const result = await deduplicateEvent(event);

     switch (result.status) {
       case 'duplicate':
         console.log(`Skipping duplicate event: ${event.name}`);
         // Optionally update existing event with new ticket link
         break;

       case 'unique':
         // Save event as new
         await upsertEvent(event);
         console.log(`Saved new event: ${event.name}`);
         break;

       case 'manual_review':
         // Save event but flag for review
         await upsertEvent(event);
         console.log(`Saved event for manual review: ${event.name}`);
         break;
     }
   }
   ```

4. Update storage/event-repository.ts to integrate deduplication:
   ```typescript
   import { deduplicateAndSave } from '../deduplication/deduplicator.js';

   // Replace direct upsertEvent calls in crawlers with:
   export async function saveEventWithDeduplication(event: Event): Promise<boolean> {
     try {
       await deduplicateAndSave(event);
       return true;
     } catch (error) {
       console.error('Failed to save event:', error);
       return false;
     }
   }
   ```

Note: The current database schema uses venue+date unique constraint for exact deduplication. For fuzzy matches, we log duplicates but the constraint prevents actual duplicates. A full implementation would store all ticket links in a separate table with foreign key to events table, allowing one event with multiple ticket sources.
  </action>
  <verify>
Test complete deduplication pipeline:
  cat > test-deduplication.ts << 'EOF'
import { deduplicateEvent } from './src/deduplication/deduplicator.js';
import { db } from './src/db/client.js';
import { events } from './src/db/schema.js';

// Insert base event
const baseEvent = {
  name: 'Jazz Night with Stockholm Trio',
  artist: 'Stockholm Jazz Trio',
  venue: 'Fasching',
  date: new Date('2026-08-10T21:00:00Z'),
  genre: 'jazz',
  ticketUrl: 'https://ticketmaster.com/event1',
  sourceId: 'tm-001',
  sourcePlatform: 'ticketmaster'
};

await db.insert(events).values(baseEvent);
console.log('Inserted base event');

// Test 1: Exact duplicate (same venue+date)
const exactDupe = { ...baseEvent, sourceId: 'axs-001', sourcePlatform: 'axs', ticketUrl: 'https://axs.com/event1' };
const result1 = await deduplicateEvent(exactDupe);
console.log('Test 1 (exact duplicate):', result1.status === 'duplicate' ? 'PASS' : 'FAIL');

// Test 2: Fuzzy duplicate (similar name, same date)
const fuzzyDupe = {
  ...baseEvent,
  name: 'Stockholm Jazz Trio - Jazz Night',
  artist: 'Stockholm Trio',
  sourceId: 'dice-001',
  sourcePlatform: 'dice'
};
const result2 = await deduplicateEvent(fuzzyDupe);
console.log('Test 2 (fuzzy duplicate):', result2.status === 'duplicate' ? 'PASS' : 'FAIL');

// Test 3: Unique event
const unique = {
  ...baseEvent,
  name: 'Rock Concert',
  artist: 'Different Band',
  date: new Date('2026-09-15T20:00:00Z'),
  sourceId: 'tm-002'
};
const result3 = await deduplicateEvent(unique);
console.log('Test 3 (unique event):', result3.status === 'unique' ? 'PASS' : 'FAIL');
EOF

  tsx test-deduplication.ts
  Expected: All three tests PASS

Test review queue:
  cat > test-review-queue.ts << 'EOF'
import { getReviewQueue } from './src/deduplication/manual-review-queue.js';

const queue = await getReviewQueue();
console.log(`Review queue has ${queue.length} items`);

if (queue.length > 0) {
  console.log('Sample item:');
  console.log('  Artist similarity:', queue[0].artistSimilarity);
  console.log('  Name similarity:', queue[0].nameSimilarity);
  console.log('  Status:', queue[0].status);
}
EOF

  tsx test-review-queue.ts
  Expected: Shows review queue items (if any maybes detected)
  </verify>
  <done>
- reviewQueue table added to database schema
- Manual review queue stores edge cases (70-90% similarity)
- deduplicateEvent orchestrates all three stages
- Exact matches detected via venue+date query
- Fuzzy matches detected via string similarity
- Edge cases queued for manual review
- getReviewQueue provides pending items for admin review
- Complete pipeline integrated with event storage
  </done>
</task>

</tasks>

<verification>
End-to-end deduplication verification:

1. Run all crawlers and check for duplicates:
   ```bash
   # Clear database
   docker exec -it $(docker-compose ps -q postgres) psql -U dev -d stockholm_events -c "TRUNCATE events CASCADE;"

   # Run crawlers
   tsx -e "import { crawlTicketmaster } from './src/crawlers/ticketmaster.js'; await crawlTicketmaster();"
   tsx -e "import { crawlAXS } from './src/crawlers/axs.js'; await crawlAXS();"
   tsx -e "import { crawlDICE } from './src/crawlers/dice.js'; await crawlDICE();"
   ```

2. Database verification:
   ```sql
   -- Check for venue+date duplicates (should be 0 due to unique constraint)
   SELECT venue, date, COUNT(*)
   FROM events
   GROUP BY venue, date
   HAVING COUNT(*) > 1;
   -- Expected: 0 rows

   -- Check review queue
   SELECT COUNT(*) FROM review_queue WHERE status = 'pending';
   -- Expected: Some items (potential fuzzy duplicates)

   -- Sample review queue items
   SELECT
     rq.artist_similarity,
     rq.name_similarity,
     e1.name as event1_name,
     e1.source_platform as platform1,
     e2.name as event2_name,
     e2.source_platform as platform2
   FROM review_queue rq
   JOIN events e1 ON rq.event_id_1 = e1.id
   JOIN events e2 ON rq.event_id_2 = e2.id
   WHERE rq.status = 'pending'
   LIMIT 5;
   -- Expected: Shows potential duplicates with similarity scores
   ```

3. Calculate deduplication accuracy:
   - Manually inspect 10-20 review queue items
   - Count true duplicates vs false positives
   - Target: >95% accuracy (QUAL-01 requirement)
   - If accuracy < 95%, adjust similarity thresholds in fuzzy-match.ts
</verification>

<success_criteria>
- Exact matching detects venue+date duplicates instantly
- Fuzzy matching detects artist/name variants with >90% similarity
- Edge cases (70-90% similarity) queued for manual review
- No venue+date duplicates exist in database (unique constraint enforced)
- Review queue contains potential duplicates for manual inspection
- Deduplication accuracy >95% based on manual review of sample
- Complete pipeline integrated with all crawlers
- System handles 4 data sources (Ticketmaster, AXS, DICE, venues) without creating duplicates
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation-multi-platform-aggregation/01-07-SUMMARY.md`
</output>
