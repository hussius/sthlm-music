---
phase: 01-data-foundation-multi-platform-aggregation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - src/db/schema.ts
  - src/db/migrations/001_initial.sql
  - src/db/client.ts
  - src/config/env.ts
  - drizzle.config.ts
  - .env.example
  - docker-compose.yml
autonomous: true
requirements:
  - DATA-06

must_haves:
  truths:
    - Database schema exists with events table
    - Events table has proper indexes for date-range queries
    - Events table has unique constraint for venue+date deduplication
    - Environment variables are validated at startup
    - PostgreSQL database is accessible from Node.js application
  artifacts:
    - path: "src/db/schema.ts"
      provides: "Drizzle ORM schema with events table"
      contains: "export const events = pgTable"
      min_lines: 50
    - path: "src/db/client.ts"
      provides: "Database connection with connection pooling"
      exports: ["db"]
      min_lines: 15
    - path: "src/config/env.ts"
      provides: "Zod-validated environment configuration"
      exports: ["config", "validateEnv"]
      min_lines: 30
    - path: "drizzle.config.ts"
      provides: "Drizzle migration configuration"
      contains: "export default"
    - path: "docker-compose.yml"
      provides: "PostgreSQL and Redis containers for development"
      contains: "postgres"
  key_links:
    - from: "src/db/client.ts"
      to: "src/db/schema.ts"
      via: "imports schema definitions"
      pattern: "import.*from.*schema"
    - from: "src/config/env.ts"
      to: "process.env"
      via: "Zod validation at startup"
      pattern: "envSchema\\.safeParse"
    - from: "src/db/schema.ts"
      to: "drizzle-orm/pg-core"
      via: "pgTable definitions"
      pattern: "pgTable\\(.*\\)"
---

<objective>
Establish the foundational infrastructure for the event aggregation system by setting up a Node.js/TypeScript project with Crawlee framework, PostgreSQL database with optimized schema for event storage and deduplication, and validated environment configuration.

Purpose: Create the technical foundation that all crawlers and data processing components will build upon. This includes the database schema that enforces data quality, indexes that enable fast queries, and configuration management that prevents runtime errors.

Output: Working Node.js project with PostgreSQL database schema, Drizzle ORM integration, Docker Compose development environment, and type-safe configuration management.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-data-foundation-multi-platform-aggregation/01-RESEARCH.md
@.planning/codebase/STACK.md
@.planning/codebase/ARCHITECTURE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Node.js TypeScript project with Crawlee and database dependencies</name>
  <files>
    package.json
    tsconfig.json
    .gitignore
    .env.example
  </files>
  <action>
Create a new Node.js project alongside the existing Python application (do not remove Python code):

1. Initialize package.json with:
   - name: "stockholm-events-crawler"
   - type: "module" (ES modules)
   - engines: node >= 20.0.0

2. Install core dependencies:
   ```bash
   npm install crawlee playwright cheerio drizzle-orm postgres zod bullmq ioredis fuzzball dotenv
   npm install -D @types/node tsx drizzle-kit typescript
   ```

3. Create tsconfig.json with:
   - target: ES2022
   - module: ESNext
   - moduleResolution: bundler
   - strict: true
   - esModuleInterop: true
   - outDir: ./dist
   - rootDir: ./src
   - resolveJsonModule: true

4. Add to .gitignore:
   - node_modules/
   - dist/
   - .env
   - storage/
   - playwright-state/

5. Create .env.example with placeholder variables:
   - DATABASE_URL=postgresql://user:password@localhost:5432/stockholm_events
   - REDIS_URL=redis://localhost:6379
   - TICKETMASTER_API_KEY=your_api_key_here
   - NODE_ENV=development
   - LOG_LEVEL=info
   - CRAWL_CONCURRENCY=5

6. Add npm scripts to package.json:
   - "dev": "tsx watch src/index.ts"
   - "build": "tsc"
   - "start": "node dist/index.js"
   - "db:generate": "drizzle-kit generate"
   - "db:migrate": "drizzle-kit migrate"
   - "db:push": "drizzle-kit push"
   - "db:studio": "drizzle-kit studio"
  </action>
  <verify>
Run: npm install && npm run build
Confirm: Build completes without errors, dist/ directory created with compiled JavaScript
Check: cat package.json | grep -E "(crawlee|drizzle-orm|playwright|zod|bullmq)"
Expected: All core dependencies present in package.json
  </verify>
  <done>
- package.json exists with all required dependencies and scripts
- tsconfig.json configured for strict TypeScript with ES modules
- Project builds successfully with tsc
- .env.example documents all required environment variables
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PostgreSQL database schema with Drizzle ORM</name>
  <files>
    src/db/schema.ts
    src/db/client.ts
    src/db/migrations/001_initial.sql
    drizzle.config.ts
  </files>
  <action>
Implement the database layer following the research recommendations:

1. Create drizzle.config.ts:
   - dialect: 'postgresql'
   - schema: './src/db/schema.ts'
   - out: './src/db/migrations'
   - dbCredentials from DATABASE_URL env var

2. Create src/db/schema.ts with events table:
   - id: uuid (primary key, default random)
   - name: text (not null) - event name
   - artist: text (not null) - artist/band name
   - venue: text (not null) - normalized venue name
   - date: timestamp with timezone (not null) - event date/time
   - time: text (optional) - display time string
   - genre: text (not null) - canonical genre
   - ticketUrl: text (not null) - link to ticket purchase
   - price: text (optional) - ticket price info
   - sourceId: text (not null) - original platform ID
   - sourcePlatform: text (not null) - ticketmaster/axs/dice/venue-direct
   - createdAt: timestamp (default now, not null)
   - updatedAt: timestamp (default now, not null)

3. Add indexes to schema:
   - uniqueIndex('venue_date_idx') on (venue, date) - exact match deduplication
   - index('date_idx') on (date) - rolling window queries
   - index('genre_idx') on (genre) - genre filtering
   - index('artist_date_idx') on (artist, date) - fuzzy match candidates
   - index('source_platform_idx') on (sourcePlatform, sourceId) - source tracking

4. Create src/db/client.ts:
   - Import postgres from 'postgres' package
   - Import drizzle from 'drizzle-orm/postgres-js'
   - Create postgres connection with config.DATABASE_URL
   - Export db = drizzle(postgres(config.DATABASE_URL), { schema })
   - Configure connection pool (max: 10, idle_timeout: 30)

5. Generate initial migration:
   Run: npm run db:generate
   Verify: Migration file created in src/db/migrations/

Note: Use the exact schema structure from RESEARCH.md (Pattern: Drizzle Schema for Events) to ensure compatibility with deduplication and query patterns.
  </action>
  <verify>
Check schema file exists and exports events table:
  cat src/db/schema.ts | grep "export const events"

Check all indexes are defined:
  cat src/db/schema.ts | grep -E "(uniqueIndex|index)" | wc -l
  Expected: 5 indexes (1 unique, 4 regular)

Verify migration generated:
  ls src/db/migrations/*.sql
  Expected: At least one .sql file exists

Test TypeScript compilation:
  npm run build
  Expected: No errors, dist/db/ directory contains compiled schema
  </verify>
  <done>
- src/db/schema.ts defines complete events table with all fields
- Events table has 5 indexes for deduplication and query performance
- src/db/client.ts exports configured Drizzle client
- Initial migration file generated successfully
- Schema matches RESEARCH.md recommendations exactly
  </done>
</task>

<task type="auto">
  <name>Task 3: Set up development environment with Docker Compose and validated configuration</name>
  <files>
    docker-compose.yml
    src/config/env.ts
    src/index.ts
  </files>
  <action>
Create the development environment and configuration validation:

1. Create docker-compose.yml with services:
   - postgres service:
     - image: postgres:17-alpine
     - environment: POSTGRES_DB=stockholm_events, POSTGRES_USER=dev, POSTGRES_PASSWORD=devpass
     - ports: 5432:5432
     - volumes: postgres_data (named volume for persistence)

   - redis service:
     - image: redis:7-alpine
     - ports: 6379:6379
     - volumes: redis_data (named volume for persistence)

2. Create src/config/env.ts with Zod validation (from RESEARCH.md example):
   - Define envSchema with z.object for all environment variables:
     - DATABASE_URL: z.string().url()
     - REDIS_URL: z.string().url()
     - TICKETMASTER_API_KEY: z.string().min(1)
     - NODE_ENV: z.enum(['development', 'production', 'test']).default('development')
     - LOG_LEVEL: z.enum(['debug', 'info', 'warn', 'error']).default('info')
     - CRAWL_CONCURRENCY: z.coerce.number().min(1).max(10).default(5)

   - Export validateEnv() function that:
     - Calls envSchema.safeParse(process.env)
     - If fails: logs formatted errors and exits with code 1
     - If succeeds: returns validated config

   - Export config constant (result of validateEnv())

3. Create src/index.ts as minimal entry point:
   - Import config from './config/env.js'
   - Import db from './db/client.js'
   - Log startup message: "Stockholm Events Crawler initialized"
   - Log config (without sensitive values): NODE_ENV, LOG_LEVEL, CRAWL_CONCURRENCY
   - Test database connection: await db.execute(sql`SELECT 1`)
   - Log: "Database connection successful"

4. Update .env.example to match docker-compose defaults for easy local development:
   DATABASE_URL=postgresql://dev:devpass@localhost:5432/stockholm_events
   REDIS_URL=redis://localhost:6379

Note: Environment validation MUST fail fast at startup (process.exit(1)) if any required variable is missing or invalid. This prevents crawls from running 3 hours then failing due to missing config.
  </action>
  <verify>
Start services and test:
  docker-compose up -d
  docker-compose ps
  Expected: postgres and redis containers running

Create local .env file (copy from .env.example, add dummy TICKETMASTER_API_KEY):
  cp .env.example .env
  echo "TICKETMASTER_API_KEY=test_key_12345" >> .env

Test invalid config fails fast:
  DATABASE_URL="" npm run dev
  Expected: Exits immediately with validation error message

Test valid config succeeds:
  npm run dev
  Expected: Logs "Database connection successful", process stays running

Test database connection from another terminal:
  docker exec -it $(docker-compose ps -q postgres) psql -U dev -d stockholm_events -c "\dt"
  Expected: Shows migrations table (or empty if not yet migrated)
  </verify>
  <done>
- docker-compose.yml provides PostgreSQL and Redis for local development
- src/config/env.ts validates all environment variables with Zod
- Invalid configuration causes immediate startup failure with clear error messages
- src/index.ts successfully connects to database and logs startup
- Development environment works end-to-end (docker-compose up -> npm run dev -> successful connection)
  </done>
</task>

</tasks>

<verification>
Full integration check:

1. Clean environment test:
   ```bash
   docker-compose down -v
   rm -rf node_modules dist
   npm install
   docker-compose up -d
   npm run db:push  # Apply schema to database
   npm run dev
   ```
   Expected: All services start, database schema applied, application connects successfully

2. Schema validation in database:
   ```bash
   docker exec -it $(docker-compose ps -q postgres) psql -U dev -d stockholm_events -c "\d events"
   ```
   Expected: Shows events table with all columns and 5 indexes

3. Configuration validation test:
   ```bash
   DATABASE_URL="invalid" npm run dev
   ```
   Expected: Exits with clear Zod validation error, does NOT attempt database connection

4. TypeScript type safety:
   ```bash
   npm run build
   ```
   Expected: No TypeScript errors, all imports resolve correctly
</verification>

<success_criteria>
- Node.js project builds without TypeScript errors
- PostgreSQL database has events table with correct schema (15 columns, 5 indexes)
- Docker Compose starts PostgreSQL and Redis successfully
- Application connects to database and validates environment on startup
- Missing or invalid environment variables cause immediate failure with clear errors
- All files follow research recommendations (Drizzle ORM patterns, Zod validation)
- Development environment is fully reproducible (docker-compose up + npm install + npm run dev)
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation-multi-platform-aggregation/01-01-SUMMARY.md`
</output>
