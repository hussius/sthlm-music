---
phase: 01-data-foundation-multi-platform-aggregation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/normalization/schemas.ts
  - src/normalization/transformers.ts
  - src/normalization/venue-mappings.ts
  - src/normalization/genre-mappings.ts
autonomous: true
requirements:
  - DATA-07

must_haves:
  truths:
    - Raw event data from any platform can be validated and transformed to common schema
    - Venue name variations are normalized to canonical names
    - Platform-specific genre labels are mapped to standard taxonomy
    - Invalid data is rejected with clear error messages
  artifacts:
    - path: "src/normalization/schemas.ts"
      provides: "Zod schemas for event validation and transformation"
      exports: ["EventSchema", "RawEventSchema"]
      min_lines: 40
    - path: "src/normalization/transformers.ts"
      provides: "Platform-specific data transformers"
      exports: ["transformTicketmasterEvent", "transformAXSEvent", "transformDICEEvent", "transformVenueEvent"]
      min_lines: 80
    - path: "src/normalization/venue-mappings.ts"
      provides: "Venue name normalization mappings"
      exports: ["normalizeVenueName", "venueAliases"]
      min_lines: 50
    - path: "src/normalization/genre-mappings.ts"
      provides: "Genre taxonomy and mapping rules"
      exports: ["mapGenre", "CANONICAL_GENRES"]
      min_lines: 60
  key_links:
    - from: "src/normalization/schemas.ts"
      to: "src/normalization/genre-mappings.ts"
      via: "genre validation uses canonical taxonomy"
      pattern: "CANONICAL_GENRES"
    - from: "src/normalization/schemas.ts"
      to: "src/normalization/venue-mappings.ts"
      via: "transform step normalizes venue names"
      pattern: "normalizeVenueName"
    - from: "src/normalization/transformers.ts"
      to: "src/normalization/schemas.ts"
      via: "validates transformed data with EventSchema"
      pattern: "EventSchema\\.safeParse"
---

<objective>
Create a robust data normalization layer that transforms heterogeneous event data from multiple platforms (Ticketmaster, AXS, DICE, venue websites) into a unified, validated schema. This ensures data quality and enables reliable deduplication downstream.

Purpose: Establish the single source of truth for what constitutes a valid event. By validating and transforming data immediately upon ingestion, we prevent bad data from entering the database and ensure all downstream components work with clean, consistent data.

Output: Zod schemas for validation, platform-specific transformers, venue name normalization, and genre taxonomy mapping.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-data-foundation-multi-platform-aggregation/01-RESEARCH.md

Note: This plan is independent of Plan 01 and can run in parallel (Wave 1). However, crawlers in Wave 2 will depend on both Plan 01 and Plan 02 being complete.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define Zod event schema with validation and transformation</name>
  <files>
    src/normalization/schemas.ts
  </files>
  <action>
Create comprehensive Zod schemas following RESEARCH.md Pattern 3 (Zod Schema Normalization):

1. Define CANONICAL_GENRES import from genre-mappings (will be created in Task 3):
   ```typescript
   import { CANONICAL_GENRES, mapGenre } from './genre-mappings.js';
   import { normalizeVenueName } from './venue-mappings.js';
   ```

2. Create EventSchema with validation and transformation:
   - name: z.string().trim().min(1).max(500)
   - artist: z.string().trim().min(1).max(500)
   - venue: z.string().trim().transform(normalizeVenueName)
   - date: z.coerce.date().refine(d => d > new Date(), { message: 'Event must be in future' })
   - time: z.string().optional()
   - genre: z.enum(CANONICAL_GENRES as any).or(z.string().transform(mapGenre))
   - ticketUrl: z.string().url()
   - price: z.string().optional()
   - sourceId: z.string().min(1)
   - sourcePlatform: z.enum(['ticketmaster', 'axs', 'dice', 'venue-direct'])

3. Add helper function normalizeEventData(raw: unknown):
   - Call EventSchema.safeParse(raw)
   - If success: return { success: true, data: result.data }
   - If error: return { success: false, errors: result.error.flatten() }

4. Export TypeScript types:
   - export type Event = z.infer<typeof EventSchema>
   - export type NormalizedEventResult = { success: true, data: Event } | { success: false, errors: any }

5. Add JSDoc comments explaining:
   - Why dates must be in future (prevents parsing errors)
   - Why venues are transformed (enables deduplication)
   - Why genres use enum OR transform (handles unknown genres gracefully)

Note: Schema MUST enforce data quality while being lenient enough to accept real-world data variations. Use .optional() for truly optional fields (time, price) but require core fields (name, artist, venue, date, genre, ticketUrl).
  </action>
  <verify>
Create test file to verify schema works:
  cat > test-schema.ts << 'EOF'
import { normalizeEventData } from './src/normalization/schemas.js';

const validEvent = {
  name: 'Test Concert',
  artist: 'Test Band',
  venue: 'Kollektivet',
  date: '2026-06-15T20:00:00Z',
  genre: 'rock',
  ticketUrl: 'https://example.com/tickets',
  sourceId: 'test-123',
  sourcePlatform: 'ticketmaster'
};

const result = normalizeEventData(validEvent);
console.log('Valid event:', result.success ? 'PASS' : 'FAIL');

const invalidEvent = { name: '', artist: 'Test' };
const result2 = normalizeEventData(invalidEvent);
console.log('Invalid event rejected:', !result2.success ? 'PASS' : 'FAIL');
EOF

  tsx test-schema.ts
  Expected: Both tests print PASS

Check schema exports:
  cat src/normalization/schemas.ts | grep -E "export (const|type|function)"
  Expected: Exports EventSchema, Event type, normalizeEventData
  </verify>
  <done>
- EventSchema validates all required fields with appropriate constraints
- Date validation ensures events are in future (catches parsing errors)
- Venue normalization and genre mapping integrated via transforms
- normalizeEventData helper provides ergonomic API for validation
- TypeScript types exported for use in other modules
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement venue name normalization with Stockholm priority venues</name>
  <files>
    src/normalization/venue-mappings.ts
  </files>
  <action>
Create venue normalization to handle naming variations from RESEARCH.md Pitfall 3:

1. Define venueAliases mapping object with all priority venues from PROJECT.md:
   ```typescript
   export const venueAliases: Record<string, string> = {
     // Kollektivet Livet variations
     'kollektivet': 'Kollektivet Livet',
     'kollektivet livet': 'Kollektivet Livet',
     'kollektivet livet stockholm': 'Kollektivet Livet',

     // Slaktkyrkan variations
     'slaktkyrkan': 'Slaktkyrkan',
     'slaktkyrkan kulturhus': 'Slaktkyrkan',
     'kulturhuset slaktkyrkan': 'Slaktkyrkan',

     // Repeat for all 13 priority venues: Hus 7, Fasching, Nalen, Fylkingen,
     // Slakthuset, Fållan, Landet, Mosebacke, Kägelbanan, Pet Sounds, Debaser
   };
   ```

2. Implement normalizeVenueName function:
   ```typescript
   export function normalizeVenueName(venue: string): string {
     const cleaned = venue.trim().toLowerCase();

     // Direct match in aliases
     if (venueAliases[cleaned]) {
       return venueAliases[cleaned];
     }

     // Check if any alias key is contained in the venue name
     // (handles "Concert at Kollektivet Livet" -> "Kollektivet Livet")
     for (const [alias, canonical] of Object.entries(venueAliases)) {
       if (cleaned.includes(alias)) {
         return canonical;
       }
     }

     // Return original with proper capitalization if no match
     return venue.trim();
   }
   ```

3. Add helper function getCanonicalVenues() that returns array of unique canonical venue names:
   ```typescript
   export function getCanonicalVenues(): string[] {
     return Array.from(new Set(Object.values(venueAliases)));
   }
   ```

4. Add tests as JSDoc examples showing:
   - "kollektivet" -> "Kollektivet Livet"
   - "Fasching Stockholm" -> "Fasching"
   - "Unknown Venue" -> "Unknown Venue" (passthrough)

Note: Mapping should be case-insensitive and handle both exact matches and substring matches. This catches variations like "Live at Kollektivet" and "Kollektivet Livet - Stockholm".
  </action>
  <verify>
Test normalization with various inputs:
  cat > test-venue.ts << 'EOF'
import { normalizeVenueName } from './src/normalization/venue-mappings.js';

const tests = [
  ['kollektivet', 'Kollektivet Livet'],
  ['Kollektivet Livet', 'Kollektivet Livet'],
  ['KOLLEKTIVET', 'Kollektivet Livet'],
  ['Live at Kollektivet', 'Kollektivet Livet'],
  ['fasching stockholm', 'Fasching'],
  ['Unknown Place', 'Unknown Place']
];

tests.forEach(([input, expected]) => {
  const result = normalizeVenueName(input);
  console.log(`${input} -> ${result}: ${result === expected ? 'PASS' : 'FAIL'}`);
});
EOF

  tsx test-venue.ts
  Expected: All tests print PASS

Verify all 13 venues covered:
  cat src/normalization/venue-mappings.ts | grep -E "': '" | wc -l
  Expected: At least 30 mappings (avg 2-3 variations per venue)
  </verify>
  <done>
- venueAliases contains mappings for all 13 priority venues
- normalizeVenueName handles exact matches and substring matches
- Normalization is case-insensitive
- Unknown venues pass through unchanged
- getCanonicalVenues provides list of normalized venue names
  </done>
</task>

<task type="auto">
  <name>Task 3: Create genre taxonomy and platform-specific transformers</name>
  <files>
    src/normalization/genre-mappings.ts
    src/normalization/transformers.ts
  </files>
  <action>
Implement genre normalization and platform transformers:

**Part A: Genre mappings (genre-mappings.ts)**

1. Define CANONICAL_GENRES array (10-12 core genres):
   ```typescript
   export const CANONICAL_GENRES = [
     'rock', 'pop', 'electronic', 'jazz', 'hip-hop',
     'metal', 'indie', 'folk', 'classical', 'world', 'other'
   ] as const;
   ```

2. Create genreMappings object with 50+ common platform variations:
   ```typescript
   const genreMappings: Record<string, typeof CANONICAL_GENRES[number]> = {
     // Rock variations
     'rock': 'rock', 'rock & roll': 'rock', 'alternative rock': 'rock',
     'punk': 'rock', 'hard rock': 'rock', 'garage rock': 'rock',

     // Electronic variations
     'electronic': 'electronic', 'techno': 'electronic', 'house': 'electronic',
     'edm': 'electronic', 'dance': 'electronic', 'club': 'electronic',

     // Jazz variations
     'jazz': 'jazz', 'bebop': 'jazz', 'fusion': 'jazz', 'swing': 'jazz',

     // Hip-hop variations
     'hip-hop': 'hip-hop', 'rap': 'hip-hop', 'hip hop': 'hip-hop',

     // Continue for all genres with common variations
   };
   ```

3. Implement mapGenre function with fuzzy fallback:
   ```typescript
   export function mapGenre(genre: string): typeof CANONICAL_GENRES[number] {
     const cleaned = genre.trim().toLowerCase();

     // Direct mapping
     if (genreMappings[cleaned]) {
       return genreMappings[cleaned];
     }

     // Substring match (e.g., "indie rock" -> "indie")
     for (const [key, canonical] of Object.entries(genreMappings)) {
       if (cleaned.includes(key) || key.includes(cleaned)) {
         return canonical;
       }
     }

     // Default to 'other' if no match
     console.warn(`Unknown genre "${genre}", mapped to "other"`);
     return 'other';
   }
   ```

**Part B: Platform transformers (transformers.ts)**

4. Create transformer functions for each platform:

   ```typescript
   import { normalizeEventData } from './schemas.js';

   export function transformTicketmasterEvent(raw: any) {
     return normalizeEventData({
       name: raw.name || raw._embedded?.attractions?.[0]?.name,
       artist: raw._embedded?.attractions?.[0]?.name || 'Unknown',
       venue: raw._embedded?.venues?.[0]?.name,
       date: raw.dates?.start?.dateTime,
       time: raw.dates?.start?.localTime,
       genre: raw.classifications?.[0]?.genre?.name || 'other',
       ticketUrl: raw.url,
       price: raw.priceRanges?.[0] ? `${raw.priceRanges[0].min}-${raw.priceRanges[0].max} ${raw.priceRanges[0].currency}` : undefined,
       sourceId: raw.id,
       sourcePlatform: 'ticketmaster'
     });
   }

   export function transformAXSEvent(raw: any) {
     return normalizeEventData({
       name: raw.name || raw.title,
       artist: raw.artist || raw.performer,
       venue: raw.venue || raw.location,
       date: raw.date || raw.eventDate,
       genre: raw.genre || raw.category || 'other',
       ticketUrl: raw.url || raw.ticketLink,
       price: raw.price,
       sourceId: raw.id || raw.eventId,
       sourcePlatform: 'axs'
     });
   }

   export function transformDICEEvent(raw: any) {
     return normalizeEventData({
       name: raw.name,
       artist: raw.artist,
       venue: raw.venue,
       date: raw.date,
       genre: raw.genre || 'other',
       ticketUrl: raw.url,
       price: raw.price,
       sourceId: raw.id,
       sourcePlatform: 'dice'
     });
   }

   export function transformVenueEvent(raw: any) {
     return normalizeEventData({
       name: raw.name,
       artist: raw.artist || raw.name, // Some venues don't separate artist/event
       venue: raw.venue,
       date: raw.date,
       genre: raw.genre || 'other',
       ticketUrl: raw.url,
       price: raw.price,
       sourceId: raw.id || `${raw.venue}-${raw.date}`,
       sourcePlatform: 'venue-direct'
     });
   }
   ```

Note: Transformers extract data from platform-specific structures then delegate validation to normalizeEventData. This separates extraction logic from validation logic. Handle missing fields gracefully (use 'other' for genre, 'Unknown' for artist if truly unavailable).
  </action>
  <verify>
Test genre mapping:
  cat > test-genre.ts << 'EOF'
import { mapGenre, CANONICAL_GENRES } from './src/normalization/genre-mappings.js';

const tests = [
  ['rock', 'rock'],
  ['Rock & Roll', 'rock'],
  ['Electronic Dance Music', 'electronic'],
  ['Hip Hop', 'hip-hop'],
  ['Unknown Genre X', 'other']
];

tests.forEach(([input, expected]) => {
  const result = mapGenre(input);
  console.log(`${input} -> ${result}: ${result === expected ? 'PASS' : 'FAIL'}`);
});

console.log(`\nCanonical genres: ${CANONICAL_GENRES.length}`);
EOF

  tsx test-genre.ts
  Expected: All tests PASS, shows 10-12 canonical genres

Test transformer:
  cat > test-transform.ts << 'EOF'
import { transformTicketmasterEvent } from './src/normalization/transformers.js';

const mockEvent = {
  id: 'test-123',
  name: 'Test Concert',
  _embedded: {
    attractions: [{ name: 'Test Band' }],
    venues: [{ name: 'Kollektivet' }]
  },
  dates: { start: { dateTime: '2026-06-15T20:00:00Z' } },
  classifications: [{ genre: { name: 'Rock' } }],
  url: 'https://example.com'
};

const result = transformTicketmasterEvent(mockEvent);
console.log('Transform success:', result.success ? 'PASS' : 'FAIL');
if (result.success) {
  console.log('Venue normalized:', result.data.venue === 'Kollektivet Livet' ? 'PASS' : 'FAIL');
  console.log('Genre normalized:', result.data.genre === 'rock' ? 'PASS' : 'FAIL');
}
EOF

  tsx test-transform.ts
  Expected: All tests PASS
  </verify>
  <done>
- CANONICAL_GENRES defines 10-12 standard genres
- genreMappings includes 50+ platform-specific variations
- mapGenre handles direct matches, substring matches, and unknown genres
- Four platform transformers extract data and validate via EventSchema
- All transformers delegate validation to normalizeEventData
- Venue and genre normalization work end-to-end
  </done>
</task>

</tasks>

<verification>
Integration test of normalization pipeline:

```typescript
// test-normalization-pipeline.ts
import { transformTicketmasterEvent, transformAXSEvent } from './src/normalization/transformers.js';

// Test 1: Ticketmaster event with venue variation
const tm = {
  id: 'tm-1',
  name: 'Jazz Night',
  _embedded: {
    attractions: [{ name: 'Stockholm Jazz Quartet' }],
    venues: [{ name: 'fasching stockholm' }]  // Test venue normalization
  },
  dates: { start: { dateTime: '2026-08-20T21:00:00Z' } },
  classifications: [{ genre: { name: 'Jazz & Blues' } }],  // Test genre mapping
  url: 'https://ticketmaster.se/event/123'
};

const result1 = transformTicketmasterEvent(tm);
console.assert(result1.success, 'Ticketmaster transform failed');
console.assert(result1.data.venue === 'Fasching', 'Venue normalization failed');
console.assert(result1.data.genre === 'jazz', 'Genre mapping failed');

// Test 2: Invalid event rejected
const invalid = { name: '', artist: 'Test' };
const result2 = transformAXSEvent(invalid);
console.assert(!result2.success, 'Invalid event should be rejected');

console.log('All normalization tests passed');
```

Expected: All assertions pass, no errors thrown
</verification>

<success_criteria>
- EventSchema validates all required fields and transforms venue/genre
- Venue normalization handles 13 priority venues with multiple variations each
- Genre taxonomy includes 10-12 canonical genres
- Genre mappings cover 50+ common platform variations
- Four platform transformers correctly extract and validate data
- Invalid data is rejected with helpful error messages
- All transformers use normalizeEventData for consistent validation
- Unknown genres map to 'other' with warning logged
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation-multi-platform-aggregation/01-02-SUMMARY.md`
</output>
