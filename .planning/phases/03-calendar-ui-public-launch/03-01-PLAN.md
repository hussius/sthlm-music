---
phase: 03-calendar-ui-public-launch
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - client/package.json
  - client/vite.config.ts
  - client/tsconfig.json
  - client/src/main.tsx
  - client/src/App.tsx
  - client/src/api/client.ts
  - client/src/api/events.ts
  - client/src/types/events.ts
  - client/src/hooks/useEvents.ts
  - client/src/lib/date.ts
  - client/src/components/EventList.tsx
  - client/src/components/SkeletonCard.tsx
  - client/index.html
autonomous: true
requirements: [DISP-01, DISP-05]

must_haves:
  truths:
    - "User can see events in chronological order in a list view"
    - "Event dates display in Stockholm timezone (Europe/Stockholm)"
    - "User can scroll to load more events automatically"
    - "Calendar shows loading states while fetching data"
  artifacts:
    - path: "client/src/App.tsx"
      provides: "Root component with TanStack Query provider"
      min_lines: 20
    - path: "client/src/hooks/useEvents.ts"
      provides: "TanStack Query infinite query hook for events API"
      exports: ["useEvents"]
    - path: "client/src/components/EventList.tsx"
      provides: "Event list with infinite scroll"
      min_lines: 40
    - path: "client/src/lib/date.ts"
      provides: "Stockholm timezone formatting utilities"
      exports: ["formatEventDate", "STOCKHOLM_TZ"]
  key_links:
    - from: "client/src/components/EventList.tsx"
      to: "client/src/hooks/useEvents.ts"
      via: "useEvents hook call"
      pattern: "useEvents\\("
    - from: "client/src/hooks/useEvents.ts"
      to: "http://localhost:3001/api/events"
      via: "fetch via apiClient"
      pattern: "apiClient.*\\/api\\/events"
    - from: "client/src/lib/date.ts"
      to: "formatInTimeZone"
      via: "date-fns-tz import"
      pattern: "import.*formatInTimeZone.*date-fns-tz"
---

<objective>
Build React application foundation with data fetching, infinite scroll, and Stockholm timezone display.

Purpose: Establish core infrastructure for displaying events from the Phase 2 API with proper pagination and timezone handling.
Output: Working React app that shows events in chronological order with infinite scroll, all times in Stockholm timezone.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-calendar-ui-public-launch/03-RESEARCH.md
@.planning/phases/02-api-layer-performance/02-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Vite React TypeScript project with TanStack Query</name>
  <files>
    client/package.json
    client/vite.config.ts
    client/tsconfig.json
    client/index.html
    client/src/main.tsx
    client/src/App.tsx
    client/src/index.css
  </files>
  <action>
Create new Vite React TypeScript project in `client/` directory using:
```bash
npm create vite@latest client -- --template react-ts
cd client
```

Install core dependencies:
```bash
npm install @tanstack/react-query @tanstack/react-query-devtools
npm install react-router-dom
npm install date-fns date-fns-tz
npm install zod
npm install -D @types/node
```

Configure vite.config.ts:
- Set server port to 3000
- Add proxy for /api to http://localhost:3001 (avoid CORS in dev)
- Configure build with vendor chunk splitting (react-vendor, query-vendor)

Update App.tsx:
- Wrap with QueryClientProvider from TanStack Query
- Create QueryClient with 60s staleTime
- Add ReactQueryDevtools in development
- Set up BrowserRouter from react-router-dom

Update main.tsx:
- Import index.css for Tailwind
- Render App with React.StrictMode

Update tsconfig.json:
- Add path alias: "@/*": ["./src/*"]
- Enable strict mode, skipLibCheck

Create index.css with Tailwind imports:
```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

Do NOT install Tailwind yet (Plan 02 handles styling). For now, use minimal inline styles or basic CSS.
  </action>
  <verify>
```bash
cd client
npm run dev
# Visit http://localhost:3000 - should see Vite + React starter page
```

Verify files exist:
```bash
ls client/src/main.tsx client/src/App.tsx client/vite.config.ts
```
  </verify>
  <done>
- Vite dev server starts on port 3000 without errors
- React app renders in browser
- TanStack Query provider wraps app
- Dependencies installed and locked in package-lock.json
  </done>
</task>

<task type="auto">
  <name>Task 2: Create API client and event data fetching layer</name>
  <files>
    client/src/api/client.ts
    client/src/api/events.ts
    client/src/types/events.ts
    client/src/hooks/useEvents.ts
    client/src/lib/date.ts
  </files>
  <action>
Create API client at `client/src/api/client.ts`:
- Export `apiClient<T>(endpoint, params)` function
- Base URL: `import.meta.env.VITE_API_URL || 'http://localhost:3001'`
- Build URL with URLSearchParams for query params
- Filter out undefined/null params
- Throw error on non-ok responses with status and statusText
- Return response.json() typed as T

Create types at `client/src/types/events.ts`:
- Copy EventFilters, TicketSource, EventResponse, EventsResponse types from Phase 2 API schema (src/api/validators/events.schema.ts)
- These are the Zod inferred types - reuse for type safety

Create events API at `client/src/api/events.ts`:
- Export `fetchEvents(filters: EventFilters)` function
- Call `apiClient<EventsResponse>('/api/events', filters)`
- Convert filters object to string params

Create date utilities at `client/src/lib/date.ts`:
- Export `STOCKHOLM_TZ = 'Europe/Stockholm'` constant
- Export `formatEventDate(isoDate: string): string` function
- Use `formatInTimeZone(new Date(isoDate), STOCKHOLM_TZ, 'EEE, MMM d, yyyy • HH:mm')`
- Import `formatInTimeZone` from 'date-fns-tz'

Create events hook at `client/src/hooks/useEvents.ts`:
- Export `useEvents(filters: EventFilters)` hook
- Use `useInfiniteQuery` from TanStack Query
- queryKey: `['events', filters]` - include all filters for proper cache invalidation
- queryFn: `({ pageParam }) => fetchEvents({ ...filters, cursor: pageParam })`
- initialPageParam: `undefined`
- getNextPageParam: `(lastPage) => lastPage.nextCursor ?? undefined`
- staleTime: 60000 (1 minute)
- refetchOnWindowFocus: false (avoid cursor issues on refetch)

Pattern: All filters in query key prevents stale data when filters change. TanStack Query automatically refetches sequentially from page 1 when key changes.
  </action>
  <verify>
Create test file `client/src/test-events.ts`:
```typescript
import { fetchEvents } from './api/events';

fetchEvents({ limit: 5 }).then(data => {
  console.log('Events:', data.events.length);
  console.log('Cursor:', data.nextCursor);
}).catch(err => console.error('Error:', err));
```

Run with tsx:
```bash
cd client
npx tsx src/test-events.ts
```

Should log event count and cursor (or error if API not running).

Delete test file after verification.
  </verify>
  <done>
- apiClient function handles URL building and error responses
- fetchEvents function calls API with proper typing
- useEvents hook uses useInfiniteQuery with correct parameters
- Types match Phase 2 API schema exactly
- formatEventDate function formats dates in Stockholm timezone
- All files compile without TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Build event list component with infinite scroll</name>
  <files>
    client/src/components/EventList.tsx
    client/src/components/SkeletonCard.tsx
    client/src/App.tsx
  </files>
  <action>
Create SkeletonCard at `client/src/components/SkeletonCard.tsx`:
- Simple loading placeholder with gray boxes
- Use inline styles or basic CSS (no Tailwind yet)
- Match approximate event card dimensions (height ~200px)
- Animate with pulsing opacity effect using CSS keyframes

Create EventList at `client/src/components/EventList.tsx`:
- Import useEvents hook and formatEventDate
- For now, pass empty filters object to useEvents: `useEvents({})`
- Use `useInView` from 'react-intersection-observer' for scroll detection
- Install if needed: `npm install react-intersection-observer`
- In useEffect: when `inView && hasNextPage && !isFetchingNextPage`, call `fetchNextPage()`
- Render states:
  - isLoading: Show 5 SkeletonCards
  - isError: Show error message in red box
  - Empty: Show "No events found" message
  - Success: Map over `data?.pages.flatMap(page => page.events) ?? []`
- For each event, render simple card with:
  - Event name (h3)
  - Artist (p)
  - Date/time using formatEventDate (p)
  - Venue (p)
  - Genre (p)
  - Basic styling with borders and padding
- After event list, render scroll trigger:
  - `<div ref={ref}>` for intersection observer
  - Show "Loading more events..." when isFetchingNextPage
  - Show nothing when !hasNextPage
- Use semantic HTML: `<div role="list">` for container, basic divs for cards

Pattern: Separate immediate UI state (inView) from API calls (fetchNextPage) for responsive infinite scroll. TanStack Query handles page merging and deduplication automatically.
  </action>
  <verify>
Start both API and frontend:
```bash
# Terminal 1 - API (from project root)
npm run dev

# Terminal 2 - Frontend
cd client
npm run dev
```

Visit http://localhost:3000:
- Initial events load and display in list
- Scroll to bottom triggers automatic loading of next page
- "Loading more..." indicator appears during fetch
- All event dates show Stockholm time format (e.g., "Fri, Feb 21, 2026 • 19:30")
- No console errors

Verify all required event fields display: name, artist, date/time, venue, genre
  </verify>
  <done>
- EventList component renders events in chronological order
- Infinite scroll works: scrolling near bottom loads next page
- Loading states show skeleton cards on initial load
- Stockholm timezone formatting applied to all dates (verified with console.log and visual check)
- Error states display user-friendly messages
- Empty state shows when no events match
- Basic styling makes content readable (borders, padding, text hierarchy)
  </done>
</task>

</tasks>

<verification>
Manual verification steps:

1. **Chronological order (DISP-01):**
   - Open http://localhost:3000
   - Verify events appear in date order (earliest to latest)
   - Scroll through multiple pages - order remains chronological

2. **Stockholm timezone (DISP-05):**
   - Check event date/time displays
   - Verify format matches "EEE, MMM d, yyyy • HH:mm" (e.g., "Fri, Feb 21, 2026 • 19:30")
   - If user is in different timezone, verify times don't shift with browser timezone changes

3. **Infinite scroll:**
   - Scroll to bottom of event list
   - Verify "Loading more..." appears
   - Verify new events append to list
   - Verify no duplicate events appear

4. **API integration:**
   - Open browser DevTools Network tab
   - Verify GET /api/events calls succeed with 200 status
   - Verify cursor parameter sent on pagination requests
   - Verify response structure matches EventsResponse type

5. **Error handling:**
   - Stop API server
   - Refresh frontend
   - Verify error message displays (not blank page or console-only error)
   - Restart API, refresh frontend, verify recovery
</verification>

<success_criteria>
Phase complete when:
- [ ] React app runs on port 3000 without errors
- [ ] Events from Phase 2 API display in chronological list
- [ ] All event dates formatted in Stockholm timezone (Europe/Stockholm)
- [ ] Infinite scroll loads additional pages automatically
- [ ] Loading skeletons display during initial fetch
- [ ] Error states handled gracefully
- [ ] TanStack Query DevTools show proper query caching
- [ ] No TypeScript compilation errors
- [ ] Basic styling makes content readable (full Tailwind styling comes in Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/03-calendar-ui-public-launch/03-01-SUMMARY.md` following the summary template.
</output>
