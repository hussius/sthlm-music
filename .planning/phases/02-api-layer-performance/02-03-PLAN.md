---
phase: 02-api-layer-performance
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/api/services/events.service.ts
  - src/api/controllers/events.controller.ts
  - src/api/routes/events.ts
  - src/api/validators/events.schema.ts
  - src/server.ts
autonomous: true
requirements: [FILT-01, FILT-02, FILT-03, FILT-04, FILT-05]

must_haves:
  truths:
    - "GET /api/events returns 200 with events array and nextCursor"
    - "API accepts genre query parameter and filters by genre"
    - "API accepts dateFrom/dateTo query parameters and filters by date range"
    - "API accepts venue query parameter and filters by venue"
    - "API accepts artistSearch query parameter and searches artist names"
    - "API accepts eventSearch query parameter and searches event names"
    - "API accepts cursor query parameter for pagination"
    - "API accepts limit query parameter (default 20, max 100)"
    - "Invalid query parameters return 400 with validation errors"
  artifacts:
    - path: "src/api/validators/events.schema.ts"
      provides: "Zod schemas for request/response validation"
      exports: ["EventFiltersSchema", "EventsResponseSchema"]
      min_lines: 30
    - path: "src/api/services/events.service.ts"
      provides: "Business logic layer for events"
      exports: ["EventsService", "eventsService"]
      min_lines: 40
    - path: "src/api/controllers/events.controller.ts"
      provides: "Request/response handling for events"
      exports: ["EventsController", "eventsController"]
      min_lines: 30
    - path: "src/api/routes/events.ts"
      provides: "Event API route definitions"
      exports: ["eventsRoutes"]
      min_lines: 40
  key_links:
    - from: "src/server.ts"
      to: "src/api/routes/events.ts"
      via: "route registration"
      pattern: "register.*eventsRoutes"
    - from: "src/api/routes/events.ts"
      to: "src/api/controllers/events.controller.ts"
      via: "controller method call"
      pattern: "eventsController\\.getEvents"
    - from: "src/api/controllers/events.controller.ts"
      to: "src/api/services/events.service.ts"
      via: "service method call"
      pattern: "eventsService\\.findEvents"
    - from: "src/api/services/events.service.ts"
      to: "src/repositories/events.repository.ts"
      via: "repository method call"
      pattern: "eventsRepository\\.findByFilters"
---

<objective>
Create complete API layer (service, controller, routes) for GET /api/events endpoint with Zod validation and comprehensive filtering support.

Purpose: Expose the events repository functionality via REST API with type-safe request validation, proper layering (routes → controllers → services → repositories), and all filter capabilities required by Phase 2.

Output: Working GET /api/events endpoint accepting all filter parameters with automatic validation, pagination, and proper HTTP responses.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-api-layer-performance/02-RESEARCH.md
@.planning/phases/02-api-layer-performance/02-01-SUMMARY.md
@.planning/phases/02-api-layer-performance/02-02-SUMMARY.md
@src/server.ts
@src/repositories/events.repository.ts
@src/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod validation schemas</name>
  <files>
    src/api/validators/events.schema.ts
  </files>
  <action>
Create src/api/validators/events.schema.ts with Zod schemas following the pattern from 02-RESEARCH.md section "Fastify with Type Providers".

**EventFiltersSchema (export):**
- genre: z.string().optional() - filter by canonical genre
- dateFrom: z.string().datetime().optional() - ISO 8601 date string for range start
- dateTo: z.string().datetime().optional() - ISO 8601 date string for range end
- venue: z.string().optional() - exact match on normalized venue name
- artistSearch: z.string().optional() - text search on artist field
- eventSearch: z.string().optional() - text search on event name field
- cursor: z.string().optional() - pagination cursor (format: "date_id")
- limit: z.number().int().min(1).max(100).default(20) - page size with bounds

Use z.coerce.number() for limit to handle query string conversion.

**TicketSourceSchema:**
- platform: z.string()
- url: z.string().url()
- addedAt: z.string().datetime()

**EventSchema:**
- id: z.string().uuid()
- name: z.string()
- artist: z.string()
- venue: z.string()
- date: z.string().datetime()
- time: z.string().nullable()
- genre: z.string()
- ticketSources: z.array(TicketSourceSchema)
- price: z.string().nullable()

**EventsResponseSchema (export):**
- events: z.array(EventSchema)
- nextCursor: z.string().nullable()

Export all schemas for use in routes and tests.
  </action>
  <verify>
Run TypeScript compilation: npm run build
Check that src/api/validators/events.schema.ts exists
Verify exports: EventFiltersSchema, EventsResponseSchema
Check Zod import and schema definitions
  </verify>
  <done>
- EventFiltersSchema validates all query parameters with types and bounds
- EventsResponseSchema validates response structure
- Schemas export z.infer types for TypeScript integration
  </done>
</task>

<task type="auto">
  <name>Task 2: Create service and controller layers</name>
  <files>
    src/api/services/events.service.ts
    src/api/controllers/events.controller.ts
  </files>
  <action>
Create src/api/services/events.service.ts following layered architecture pattern:

**EventsService class:**

1. **findEvents(filters) method:**
   - Accept filters parameter matching EventFilters interface
   - Apply default limit if not provided: filters.limit = filters.limit || 20
   - Validate limit bounds: throw error if > 100 or < 1
   - Call eventsRepository.findByFilters(filters)
   - Return result (events array + nextCursor)

2. **Export singleton:**
   - Import eventsRepository from '../../repositories/events.repository.js'
   - Export const eventsService = new EventsService()

Create src/api/controllers/events.controller.ts:

**EventsController class:**

1. **getEvents(request, reply) method:**
   - Accept FastifyRequest and FastifyReply (typed)
   - Query parameters already validated by Fastify (EventFiltersSchema)
   - Extract filters from request.query
   - Call eventsService.findEvents(filters)
   - Return result via reply.send()
   - Wrap in try/catch: on error, reply.status(500).send({ error: 'Internal server error' })

2. **Export singleton:**
   - Import eventsService from '../services/events.service.js'
   - Import types from fastify
   - Export const eventsController = new EventsController()

Follow pattern from 02-RESEARCH.md section "Layered Architecture" - controllers handle HTTP, services handle business logic, repositories handle data access.
  </action>
  <verify>
Run TypeScript compilation: npm run build
Check both files exist and export singletons
Verify service imports repository
Verify controller imports service
Check error handling in controller
  </verify>
  <done>
- EventsService provides business logic layer with validation
- EventsController handles HTTP request/response
- Both export singleton instances
- Error handling returns 500 with message
- Imports follow ES module conventions (.js extensions)
  </done>
</task>

<task type="auto">
  <name>Task 3: Create events routes and register in server</name>
  <files>
    src/api/routes/events.ts
    src/server.ts
  </files>
  <action>
Create src/api/routes/events.ts following pattern from 02-RESEARCH.md section "Fastify with Type Providers":

**eventsRoutes plugin function:**

```typescript
import type { FastifyInstance } from 'fastify';
import { EventFiltersSchema, EventsResponseSchema } from '../validators/events.schema.js';
import { eventsController } from '../controllers/events.controller.js';

export async function eventsRoutes(fastify: FastifyInstance) {
  // GET /api/events - List events with filtering and pagination
  fastify.get('/api/events', {
    schema: {
      querystring: EventFiltersSchema,
      response: {
        200: EventsResponseSchema
      }
    }
  }, eventsController.getEvents.bind(eventsController));
}
```

**Key details:**
- Use schema for automatic validation and serialization
- Bind controller method to preserve 'this' context
- Export as async function for Fastify plugin registration
- Follow Fastify type provider pattern for type inference

Update src/server.ts:
- Import eventsRoutes from './api/routes/events.js'
- Register after health routes: await fastify.register(eventsRoutes)
- Keep existing health and middleware registrations
  </action>
  <verify>
Run TypeScript compilation: npm run build
Check src/api/routes/events.ts exists and exports eventsRoutes
Check src/server.ts imports and registers eventsRoutes
Start server: npm run dev
Test endpoint: curl "http://localhost:3000/api/events?limit=5"
Verify response has events array and nextCursor field
Test with filters: curl "http://localhost:3000/api/events?genre=rock&limit=10"
Test invalid limit: curl "http://localhost:3000/api/events?limit=500"
Verify 400 response for validation error
Stop server with Ctrl+C
  </verify>
  <done>
- src/api/routes/events.ts defines GET /api/events with Zod validation
- Route registered in src/server.ts
- Endpoint returns 200 with validated response structure
- Query parameter validation works (400 on invalid input)
- All filter parameters accepted and processed
- Cursor pagination functional
  </done>
</task>

</tasks>

<verification>
1. Build verification:
   - npm run build compiles without errors
   - All new files exist in dist/

2. Server verification:
   - npm run dev starts server
   - No errors in console

3. Endpoint testing:
   - Basic query: curl "http://localhost:3000/api/events?limit=5"
     - Returns 200 with events array and nextCursor
   - Genre filter: curl "http://localhost:3000/api/events?genre=rock"
     - Returns only rock events
   - Date range filter: curl "http://localhost:3000/api/events?dateFrom=2024-01-01T00:00:00Z&dateTo=2024-12-31T23:59:59Z"
     - Returns events in range
   - Search filter: curl "http://localhost:3000/api/events?artistSearch=metallica"
     - Returns matching events
   - Validation error: curl "http://localhost:3000/api/events?limit=500"
     - Returns 400 with error message

4. Response structure:
   - Check response has { events: [], nextCursor: null }
   - Check X-Response-Time header present
   - Check each event has required fields (id, name, artist, venue, date, genre)
</verification>

<success_criteria>
- GET /api/events endpoint accessible and returns 200
- All filter parameters work correctly (genre, date range, venue, artist/event search)
- Cursor pagination functional with nextCursor
- Query parameter validation returns 400 for invalid input
- Response structure matches EventsResponseSchema
- Layered architecture implemented (routes → controller → service → repository)
- Ready for load testing in 02-04
</success_criteria>

<output>
After completion, create `.planning/phases/02-api-layer-performance/02-03-SUMMARY.md` using the summary template.
</output>
