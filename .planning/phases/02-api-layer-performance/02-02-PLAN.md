---
phase: 02-api-layer-performance
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/migrations/0001_add_trigram_indexes.sql
  - drizzle.config.ts
  - src/repositories/events.repository.ts
autonomous: true
requirements: [FILT-01, FILT-02, FILT-03, FILT-04, FILT-05, PERF-01, PERF-02]

must_haves:
  truths:
    - "Database has pg_trgm extension enabled"
    - "GIN trigram indexes exist on artist and name columns"
    - "ILIKE queries on artist/name use indexes (not sequential scan)"
    - "Repository can filter events by date range within 200ms"
    - "Repository can filter events by genre within 200ms"
    - "Repository can filter events by venue within 200ms"
    - "Repository can search events by artist name within 200ms"
    - "Repository can search events by event name within 200ms"
  artifacts:
    - path: "src/db/migrations/0001_add_trigram_indexes.sql"
      provides: "GIN trigram indexes for text search"
      contains: "CREATE EXTENSION IF NOT EXISTS pg_trgm"
      min_lines: 15
    - path: "src/repositories/events.repository.ts"
      provides: "Event filtering and search with cursor pagination"
      exports: ["EventsRepository", "EventFilters"]
      min_lines: 100
  key_links:
    - from: "src/repositories/events.repository.ts"
      to: "src/db/schema.ts"
      via: "import events table"
      pattern: "import.*events.*from.*schema"
    - from: "src/repositories/events.repository.ts"
      to: "drizzle-orm operators"
      via: "query building with eq, gte, lte, ilike, and, or"
      pattern: "import.*eq.*gte.*lte.*ilike.*from.*drizzle-orm"
---

<objective>
Create PostgreSQL GIN trigram indexes for fast text search and implement comprehensive event filtering repository with cursor-based pagination.

Purpose: Enable sub-200ms response times for all filter combinations (date, genre, venue, artist/event name search) by leveraging database-level indexing and optimized query patterns.

Output: Database migration adding trigram indexes and production-ready events repository supporting all filter requirements with cursor pagination.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-api-layer-performance/02-RESEARCH.md
@src/db/schema.ts
@src/db/client.ts
@drizzle.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GIN trigram indexes migration</name>
  <files>
    src/db/migrations/0001_add_trigram_indexes.sql
  </files>
  <action>
Create migration file src/db/migrations/0001_add_trigram_indexes.sql following the pattern from 02-RESEARCH.md section "GIN Trigram Index Migration":

Migration content:
```sql
-- Enable pg_trgm extension for trigram-based text search
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- Create GIN trigram indexes for artist and name columns
-- GIN (Generalized Inverted Index) is preferred over GiST for read-heavy workloads
-- These indexes enable fast ILIKE searches with leading wildcards (e.g., '%metallica%')

CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_events_artist_trgm
  ON events USING GIN (artist gin_trgm_ops);

CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_events_name_trgm
  ON events USING GIN (name gin_trgm_ops);

-- Verify indexes were created (for testing/debugging)
-- SELECT schemaname, tablename, indexname, indexdef
-- FROM pg_indexes
-- WHERE tablename = 'events' AND indexname LIKE '%trgm%';
```

**Important:** Use CONCURRENTLY to avoid locking the table during index creation (safe for production). Use IF NOT EXISTS to make migration idempotent.

After creating the file, apply the migration:
```bash
npm run db:push
```

This runs Drizzle's push command which applies pending migrations to the database.
  </action>
  <verify>
Check migration file exists: ls src/db/migrations/0001_add_trigram_indexes.sql
Run migration: npm run db:push
Query PostgreSQL to verify extension and indexes exist:
```bash
# Start psql (from docker-compose)
docker exec -it $(docker ps -q -f name=postgres) psql -U postgres -d events

# In psql, run:
\dx pg_trgm
\d events
\q
```
Verify output shows pg_trgm extension and idx_events_artist_trgm, idx_events_name_trgm indexes.
  </verify>
  <done>
- Migration file created with pg_trgm extension and GIN trigram indexes
- Migration applied successfully to database
- pg_trgm extension enabled
- idx_events_artist_trgm and idx_events_name_trgm indexes exist on events table
  </done>
</task>

<task type="auto">
  <name>Task 2: Create events repository with comprehensive filtering</name>
  <files>
    src/repositories/events.repository.ts
  </files>
  <action>
Create src/repositories/events.repository.ts implementing the pattern from 02-RESEARCH.md section "Drizzle Query with Multiple Filters".

Repository structure:

1. **Imports:**
   - Import eq, gte, lte, ilike, and, or, gt from 'drizzle-orm'
   - Import events, Event from '../db/schema.js'
   - Import db from '../db/client.js'

2. **EventFilters interface (export):**
   ```typescript
   export interface EventFilters {
     genre?: string;
     dateFrom?: string;  // ISO date string
     dateTo?: string;    // ISO date string
     venue?: string;
     artistSearch?: string;
     eventSearch?: string;
     cursor?: string;    // Format: "date_id" (e.g., "2024-03-15T19:00:00Z_uuid")
     limit?: number;     // Default 20, max 100
   }
   ```

3. **EventsRepository class (export):**

   **findByFilters(filters: EventFilters) method:**
   - Build conditions array dynamically
   - Add eq(events.genre, filters.genre) if genre provided
   - Add gte(events.date, new Date(filters.dateFrom)) if dateFrom provided
   - Add lte(events.date, new Date(filters.dateTo)) if dateTo provided
   - Add eq(events.venue, filters.venue) if venue provided
   - Add ilike(events.artist, `%${filters.artistSearch}%`) if artistSearch provided
   - Add ilike(events.name, `%${filters.eventSearch}%`) if eventSearch provided

   **Cursor pagination logic:**
   - If cursor provided, parse into cursorDate and cursorId
   - Add condition: or(gt(events.date, cursorDate), and(eq(events.date, cursorDate), gt(events.id, cursorId)))

   **Query execution:**
   - Select specific columns (not SELECT *): id, name, artist, venue, date, time, genre, ticketSources, price
   - Use and(...conditions) in where clause
   - Order by events.date, events.id (consistent ordering for cursor pagination)
   - Limit to filters.limit + 1 (fetch extra to determine if more pages exist)

   **Response formatting:**
   - Check hasMore = results.length > filters.limit
   - Slice to actual page size: items = hasMore ? results.slice(0, -1) : results
   - Build nextCursor if hasMore: format as `${date.toISOString()}_${id}`
   - Return { events: items, nextCursor: nextCursor || null }

4. **Helper functions:**
   - parseCursor(cursor: string): { date: Date, id: string } - split on '_'
   - buildCursor(date: Date, id: string): string - join with '_'

5. **Class instantiation:**
   - Export const eventsRepository = new EventsRepository()

Follow TypeScript conventions: strict types, async/await, explicit return types.
  </action>
  <verify>
Run TypeScript compilation: npm run build
Check that src/repositories/events.repository.ts exists
Verify exports: EventFilters interface, EventsRepository class, eventsRepository instance
Check import statements reference correct paths with .js extensions (ES modules)
  </verify>
  <done>
- src/repositories/events.repository.ts implements comprehensive filtering
- EventFilters interface defines all filter parameters
- EventsRepository.findByFilters() supports all filter combinations
- Cursor pagination implemented with consistent ordering
- Repository uses Drizzle operators (eq, gte, lte, ilike, and, or) for type safety
- Exports eventsRepository singleton instance
  </done>
</task>

</tasks>

<verification>
1. Migration verification:
   - Check migration file exists and contains pg_trgm extension + GIN indexes
   - Run npm run db:push successfully
   - Verify indexes in database using psql \d events command

2. Repository verification:
   - Run npm run build - TypeScript compiles without errors
   - Check EventFilters interface exports all filter fields
   - Check EventsRepository class exports findByFilters method
   - Verify cursor pagination logic (limit + 1, nextCursor calculation)
   - Verify all Drizzle operators imported and used correctly

3. Integration readiness:
   - Repository exports eventsRepository singleton
   - All imports use .js extensions for ES modules
   - Return type includes events array and nullable nextCursor
</verification>

<success_criteria>
- PostgreSQL has pg_trgm extension enabled
- GIN trigram indexes exist on events.artist and events.name
- EventsRepository supports all 6 filter types (date range, genre, venue, artist search, event search, cursor)
- Cursor pagination implemented with O(1) performance
- Repository uses database-level filtering (not in-memory)
- All queries use Drizzle operators (type-safe, no SQL injection)
- Ready for service layer integration in 02-03
</success_criteria>

<output>
After completion, create `.planning/phases/02-api-layer-performance/02-02-SUMMARY.md` using the summary template.
</output>
